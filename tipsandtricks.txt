fold lvl 1 : ctrl + (K -> 1)
print_endline (Blist.to_string "\n" Indrule.to_string rules) ;

backtrace: OCAMLRUNPARAM=b (exec...)

Search for proof containing certain rules:
Trying to close node: (?=([^](?!\n\n))*L.Unf.([^](?!\n\n))*R.Unf.([^](?!\n\n))*R.Unf.)(?=([^](?!\n\n))*Pto)



[ ( "-m"
    , Arg.Set_int minbound
    , ": set starting depth for IDFS to <int>, default is "
    ^ string_of_int !minbound )
; ( "-M"
    , Arg.Set_int maxbound
    , ": set maximum depth for IDFS to <int>, 0 disables it, default is "
    ^ string_of_int !maxbound )
; ( "-L"
    , Arg.Int
        (fun n ->
        minbound := n ;
        maxbound := n )
    , ": set both depths to <int>." )
; ("-p", Arg.Set show_proof, ": show proof")
; ("-d", Arg.Set do_debug, ": print debug messages")
; ("-s", Arg.Set Stats.do_statistics, ": print statistics")
; ("-l", Arg.Set_string latex_path, ": write proofs to <file>")
; ( "-t"
    , Arg.Set_int timeout
    , ": set timeout in seconds to <int>, 0 disables it, default is "
    ^ string_of_int !timeout ) ] )
[ ( "-D"
    , Arg.Set_string defs_path
    , ": read inductive definitions from <file>, default is "
    ^ !defs_path )
; ( "-emp"
    , Arg.Set parse_null_as_emp
    , "parse the empty string as the formula [emp] rather than [False], "
    ^ "default is "
    ^ string_of_bool !parse_null_as_emp )
; ( "-Lem"
    , Arg.Int Rules.set_lemma_level
    , ": specify the permissiveness of the lemma application strategy"
    ^ "\n"
    ^ Rules.lemma_option_descr_str () )
; ( "-S"
    , Arg.Set_string cl_sequent
    , ": prove the SL sequent provided in <string>" )
; ( "-test"
    , Arg.Set do_testing
    , ": test qsl" ) ];;

--------TODO---------

Need to do:
proof pto intro and other rule for supremum not replace
proof figure out tags and constraints -> lhs why existential? rhs at all? + lemma rename tag and constr
proof eqs/deqs equal cut for suprema

test on server

maybe with higher prio depending on testing:
(evtl: pto_intro proof existentials and heap equates)
(maybe rationals and no splitting ...?)

maybe:
Ubound intro not own nil!=a * nil!=b * a!=b * a->w * b->c *
                    ListLen[b](w, b) * 1rule to reduce depth?
rest of predicate definitions include again

not:
optimize calls of unify/subsumed, maybe store in sum or something
optimize unify/subsumed with General Assignment Problem? Make time measurements of calls
try new proof call after lemma app. (or maybe even split sum?) for speed up?



Rules for which predicate becomes non precise:
pto_intro_rule
instantiate_pto
pred_intro_rule
cut

Rules for which predicate stays precise (proof):
lhs/rhs_disj_to_symheaps
lhs_instantiate_ex_tags
eq_simplify
deq_simplify
eq_subst_rule
split_sum_rule
split_conform_predicate_summand
constraint_simplify
constraint_match_tag_instantiate
upper_bound_tag_instantiate
bounds_intro
ruf
luf

Rules for which predicate possibly recovers precise (proof):
lhs_instantiate_ex_vars
eq_ex_subst_rule
norm









old with equates
let pto_intro_rule =
  let rl ((_, (tag_r, _)) as seq) =
    try
      let (cs, ls), (cs', rs) = Seq.dest_sum seq in
      match (ls, rs) with
       | (_, []) | ([], _) -> []
       | (l1 :: lstail, r1 :: rstail) ->
        let (lys, ((rx, rys) as pr)) = lptos_list, rptos_list
          Ptos.fold
            (fun ((x, ys) as p) ((lptos_list_res, rptos_list_res) as res) ->
              let rptos_list = [p] @ ( Blist.map (fun h -> (*find pto in all summands*)
                Ptos.find_opt (fun (a,bs) ->
                  (Heap.equates h a x || Heap.equates r1 a x) && Blist.foldl (fun (res, ys) b ->
                    match ys with 
                      | [] -> (false, ys)
                      | y :: ys -> (res && (Heap.equates h b y || Heap.equates r1 b y), ys)
                  ) (true, ys) bs
                ) h.SH.ptos
              ) rstail ) in
              if not (Blist.is_empty lptos_list_res) then res
              else if not (Blist.for_all (fun pto -> Option.is_some pto) rptos_list) then res
              else
                let lptos_list = Blist.find_map
                  (fun ((lx', lys') as p') -> 
                    let check1 = (Heap.equates l1 lx' x || Heap.equates r1 lx' x) 
                    && Blist.for_all (fun ly -> not (Term.is_exist_var ly)) lys' in (*avoid scope jumping*)
                    if not check1 then None else
                    let check2 = [p'] @ ( Blist.map (fun h -> (*find pto in all summands*)
                      Ptos.find_opt (fun (a,bs) ->
                        (Heap.equates h a lx' || Heap.equates l1 a lx') && Blist.foldl (fun (res, ys) b ->
                          match ys with 
                            | [] -> (false, ys)
                            | y :: ys -> (res && (Heap.equates h b y || Heap.equates l1 b y), ys)
                        ) (true, lys') bs
                      ) h.SH.ptos
                    ) lstail ) in
                    if not (Blist.for_all (fun pto -> Option.is_some pto) check2) then None
                    else Some(check2)
                  ) (Ptos.to_list l1.SH.ptos) in
                match lptos_list with
                  | None -> res
                  | Some (lptos_list) -> 
                    let rptos_list = Blist.map (fun pto -> Option.get pto) rptos_list in
                    let lptos_list = Blist.map (fun pto -> Option.get pto) lptos_list in
                    (lptos_list, rptos_list) 
            ) r1.SH.ptos ([], (Term.of_string "a", []))
        in
        if Blist.is_empty lptos_list then []
        else
          (* take care to remove only the 1st match *)
          let ls' = Blist.foldl (fun ls' l -> 
            match lptos_list with
              | [] -> ls' @ [l]
              | lpto :: lptos_list ->
                ls' @ [lose_precise_preds (SH.del_pto l lpto)]
          ) [] ls in
          let lys = Pair.snd (Blist.nth 0 lptos_list) in
          let rs' = Blist.foldl (fun rs' r -> 
            match rptos_list with
              | [] -> rs' @ [r]
              | ((_, rys) as rpto) :: rptos_list ->
                let r' = SH.del_pto r rpto in
                rs' @ [lose_precise_preds (SH.with_eqs r' (Uf.union r'.SH.eqs (Uf.of_list (Blist.combine rys lys))))]
          ) [] rs in
          let repl_vars = Term.Set.filter Term.is_exist_var (Term.Set.of_list (
            (Blist.map (fun (x,_) -> x) lptos_list)
            @ (Blist.flatten (Blist.map (fun (x,zs) -> [x] @ zs) rptos_list))
          )) in
          let avoid_vars = Term.Set.union (Heapsum.vars ls') (Heapsum.vars rs') in
          let theta = Subst.mk_free_subst avoid_vars repl_vars in
          let ls' = if Term.Map.is_empty theta then ls' else Heapsum.subst theta ls' in
          let rs' = if Term.Map.is_empty theta then rs' else Heapsum.subst theta rs' in
          let new_tag, new_cs, vts, pts = calc_new_left_constraints seq in
          [ ( [(((new_tag, (new_cs, [ls'])), (tag_r, (cs', [rs']))), vts, pts)]
            , "Pto Intro" ) ]
    with
    | Not_symheap_sum | Not_found | Invalid_argument _ -> []
  in
  wrap rl